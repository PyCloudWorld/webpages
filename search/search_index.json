{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyCloudWorld Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Home"},{"location":"#welcome-to-pycloudworld","text":"","title":"Welcome to PyCloudWorld"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"learning/azure/compute_resources/azure_containers/","text":"Azure Container Commands to install on ubuntu Update the package index sudo apt-get update Install packages to allow apt to use the repository over HTTPS sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release Add Docker's official GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg Setup a stable repository echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null Update the package index sudo apt-get update Install docker, containerd sudo apt-get install docker-ce docker-ce-cli containerd.io Launching a container sudo docker run --name mynginx -p 80:80 -d nginx Docker command explanation sudo docker run --name mynginx -p 80:80 -d nginx nginx : docker image name mynginx : name of the container 80:80 : port that needs to be mapped Azure Container Registry this is the place where we save our images for the organisation. this will be a private repo to save the container images.","title":"Azure Containers"},{"location":"learning/azure/compute_resources/azure_containers/#azure-container","text":"","title":"Azure Container"},{"location":"learning/azure/compute_resources/azure_containers/#commands-to-install-on-ubuntu","text":"Update the package index sudo apt-get update Install packages to allow apt to use the repository over HTTPS sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release Add Docker's official GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg Setup a stable repository echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null Update the package index sudo apt-get update Install docker, containerd sudo apt-get install docker-ce docker-ce-cli containerd.io Launching a container sudo docker run --name mynginx -p 80:80 -d nginx","title":"Commands to install on ubuntu"},{"location":"learning/azure/compute_resources/azure_containers/#docker-command-explanation","text":"sudo docker run --name mynginx -p 80:80 -d nginx nginx : docker image name mynginx : name of the container 80:80 : port that needs to be mapped","title":"Docker command explanation"},{"location":"learning/azure/compute_resources/azure_containers/#azure-container-registry","text":"this is the place where we save our images for the organisation. this will be a private repo to save the container images.","title":"Azure Container Registry"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/","text":"Network Interface & CIDR Notation Network Interface IP basic concept IP basic concept IP & Masking IP Number of host available IP masking shorthand IP host count IP having multiple Subnet Multiple interface on same VM or Server","title":"Network Interface & CIDR Notation"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#network-interface-cidr-notation","text":"","title":"Network Interface &amp; CIDR Notation"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#network-interface","text":"","title":"Network Interface"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#ip-basic-concept","text":"","title":"IP basic concept"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#ip-basic-concept_1","text":"","title":"IP basic concept"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#ip-masking","text":"","title":"IP &amp; Masking"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#ip-number-of-host-available","text":"","title":"IP Number of host available"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#ip-masking-shorthand","text":"","title":"IP masking shorthand"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#ip-host-count","text":"","title":"IP host count"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#ip-having-multiple-subnet","text":"","title":"IP having multiple Subnet"},{"location":"learning/azure/virtual_networking/network_interface_n_cidr_notation/#multiple-interface-on-same-vm-or-server","text":"","title":"Multiple interface on same VM or Server"},{"location":"programming/design_patterns/creational_design_patterns/builder/","text":"Builder CODE from __future__ import annotations from abc import ABC, abstractmethod from typing import Any class Builder(ABC): @property @abstractmethod def product(self) -> None: pass @abstractmethod def produce_part_a(self) -> None: pass @abstractmethod def produce_part_b(self) -> None: pass @abstractmethod def produce_part_c(self) -> None: pass class ConcreteBuilder1(Builder): def __init__(self) -> None: self.reset() def reset(self) -> None: self._product = Product1() @property def product(self) -> Product1: product = self._product self.reset() return product def produce_part_a(self) -> None: self._product.add(\"PartA1\") def produce_part_b(self) -> None: self._product.add(\"PartB1\") def produce_part_c(self) -> None: self._product.add(\"PartC1\") class Product1(): def __init__(self) -> None: self.parts = [] def add(self, part: Any) -> None: self.parts.append(part) def list_parts(self) -> None: print(f\"Product parts: {', '.join(self.parts)}\", end=\"\") class Director: def __init__(self) -> None: self._builder = None @property def builder(self) -> Builder: return self._builder @builder.setter def builder(self, builder: Builder) -> None: self._builder = builder def build_minimal_viable_product(self) -> None: self.builder.produce_part_a() def build_full_featured_product(self) -> None: self.builder.produce_part_a() self.builder.produce_part_b() self.builder.produce_part_c() if __name__ == \"__main__\": director = Director() builder = ConcreteBuilder1() director.builder = builder print(\"Standard basic product: \") director.build_minimal_viable_product() builder.product.list_parts() print(\"\\n\") print(\"Standard full featured product: \") director.build_full_featured_product() builder.product.list_parts() print(\"\\n\") # Remember, the Builder pattern can be used without a Director class. print(\"Custom product: \") builder.produce_part_a() builder.produce_part_b() builder.product.list_parts() Output.txt: Execution result Standard basic product: Product parts: PartA1 Standard full featured product: Product parts: PartA1, PartB1, PartC1 Custom product: Product parts: PartA1, PartB1","title":"Builder"},{"location":"programming/design_patterns/creational_design_patterns/builder/#builder","text":"","title":"Builder"},{"location":"programming/design_patterns/creational_design_patterns/builder/#code","text":"from __future__ import annotations from abc import ABC, abstractmethod from typing import Any class Builder(ABC): @property @abstractmethod def product(self) -> None: pass @abstractmethod def produce_part_a(self) -> None: pass @abstractmethod def produce_part_b(self) -> None: pass @abstractmethod def produce_part_c(self) -> None: pass class ConcreteBuilder1(Builder): def __init__(self) -> None: self.reset() def reset(self) -> None: self._product = Product1() @property def product(self) -> Product1: product = self._product self.reset() return product def produce_part_a(self) -> None: self._product.add(\"PartA1\") def produce_part_b(self) -> None: self._product.add(\"PartB1\") def produce_part_c(self) -> None: self._product.add(\"PartC1\") class Product1(): def __init__(self) -> None: self.parts = [] def add(self, part: Any) -> None: self.parts.append(part) def list_parts(self) -> None: print(f\"Product parts: {', '.join(self.parts)}\", end=\"\") class Director: def __init__(self) -> None: self._builder = None @property def builder(self) -> Builder: return self._builder @builder.setter def builder(self, builder: Builder) -> None: self._builder = builder def build_minimal_viable_product(self) -> None: self.builder.produce_part_a() def build_full_featured_product(self) -> None: self.builder.produce_part_a() self.builder.produce_part_b() self.builder.produce_part_c() if __name__ == \"__main__\": director = Director() builder = ConcreteBuilder1() director.builder = builder print(\"Standard basic product: \") director.build_minimal_viable_product() builder.product.list_parts() print(\"\\n\") print(\"Standard full featured product: \") director.build_full_featured_product() builder.product.list_parts() print(\"\\n\") # Remember, the Builder pattern can be used without a Director class. print(\"Custom product: \") builder.produce_part_a() builder.produce_part_b() builder.product.list_parts() Output.txt: Execution result Standard basic product: Product parts: PartA1 Standard full featured product: Product parts: PartA1, PartB1, PartC1 Custom product: Product parts: PartA1, PartB1","title":"CODE"},{"location":"programming/design_patterns/creational_design_patterns/singleton/","text":"Singleton CODE class SingletonMeta(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: instance = super().__call__(*args, **kwargs) cls._instances[cls] = instance return cls._instances[cls] class Singleton(metaclass=SingletonMeta): def some_business_logic(self): pass if __name__ == \"__main__\": s1 = Singleton() s2 = Singleton() if id(s1) == id(s2): print(\"Singleton works, both variables contain the same instance.\") else: print(\"Singleton failed, variables contain different instances.\")","title":"Singleton"},{"location":"programming/design_patterns/creational_design_patterns/singleton/#singleton","text":"","title":"Singleton"},{"location":"programming/design_patterns/creational_design_patterns/singleton/#code","text":"class SingletonMeta(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: instance = super().__call__(*args, **kwargs) cls._instances[cls] = instance return cls._instances[cls] class Singleton(metaclass=SingletonMeta): def some_business_logic(self): pass if __name__ == \"__main__\": s1 = Singleton() s2 = Singleton() if id(s1) == id(s2): print(\"Singleton works, both variables contain the same instance.\") else: print(\"Singleton failed, variables contain different instances.\")","title":"CODE"},{"location":"programming/design_patterns/structural_patterns/proxy/","text":"Proxy Problem Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always. You could implement lazy initialization: create this object only when it\u2019s actually needed. All of the object\u2019s clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication. Solution The Proxy pattern suggests that you create a new proxy class with the same interface as an original service object. Then you update your app so that it passes the proxy object to all of the original object\u2019s clients. Upon receiving a request from a client, the proxy creates a real service object and delegates all the work to it. But what\u2019s the benefit? If you need to execute something either before or after the primary logic of the class, the proxy lets you do this without changing that class. Since the proxy implements the same interface as the original class, it can be passed to any client that expects a real service object. CODE from abc import ABC, abstractmethod class Subject(ABC): @abstractmethod def request(self) -> None: pass class RealSubject(Subject): def request(self) -> None: print(\"RealSubject: Handling request.\") class Proxy(Subject): def __init__(self, real_subject: RealSubject) -> None: self._real_subject = real_subject def request(self) -> None: if self.check_access(): self._real_subject.request() self.log_access() def check_access(self) -> bool: print(\"Proxy: Checking access prior to firing a real request.\") return True def log_access(self) -> None: print(\"Proxy: Logging the time of request.\", end=\"\") def client_code(subject: Subject) -> None: subject.request() if __name__ == \"__main__\": print(\"Client: Executing the client code with a real subject:\") real_subject = RealSubject() client_code(real_subject) print(\"\") print(\"Client: Executing the same client code with a proxy:\") proxy = Proxy(real_subject) client_code(proxy) Output.txt: Execution result Client: Executing the client code with a real subject: RealSubject: Handling request. Client: Executing the same client code with a proxy: Proxy: Checking access prior to firing a real request. RealSubject: Handling request. Proxy: Logging the time of request.","title":"Proxy"},{"location":"programming/design_patterns/structural_patterns/proxy/#proxy","text":"","title":"Proxy"},{"location":"programming/design_patterns/structural_patterns/proxy/#problem","text":"Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always. You could implement lazy initialization: create this object only when it\u2019s actually needed. All of the object\u2019s clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication.","title":"Problem"},{"location":"programming/design_patterns/structural_patterns/proxy/#solution","text":"The Proxy pattern suggests that you create a new proxy class with the same interface as an original service object. Then you update your app so that it passes the proxy object to all of the original object\u2019s clients. Upon receiving a request from a client, the proxy creates a real service object and delegates all the work to it. But what\u2019s the benefit? If you need to execute something either before or after the primary logic of the class, the proxy lets you do this without changing that class. Since the proxy implements the same interface as the original class, it can be passed to any client that expects a real service object.","title":"Solution"},{"location":"programming/design_patterns/structural_patterns/proxy/#code","text":"from abc import ABC, abstractmethod class Subject(ABC): @abstractmethod def request(self) -> None: pass class RealSubject(Subject): def request(self) -> None: print(\"RealSubject: Handling request.\") class Proxy(Subject): def __init__(self, real_subject: RealSubject) -> None: self._real_subject = real_subject def request(self) -> None: if self.check_access(): self._real_subject.request() self.log_access() def check_access(self) -> bool: print(\"Proxy: Checking access prior to firing a real request.\") return True def log_access(self) -> None: print(\"Proxy: Logging the time of request.\", end=\"\") def client_code(subject: Subject) -> None: subject.request() if __name__ == \"__main__\": print(\"Client: Executing the client code with a real subject:\") real_subject = RealSubject() client_code(real_subject) print(\"\") print(\"Client: Executing the same client code with a proxy:\") proxy = Proxy(real_subject) client_code(proxy) Output.txt: Execution result Client: Executing the client code with a real subject: RealSubject: Handling request. Client: Executing the same client code with a proxy: Proxy: Checking access prior to firing a real request. RealSubject: Handling request. Proxy: Logging the time of request.","title":"CODE"}]}